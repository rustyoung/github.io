##java多线程篇

####多线程有什么用
	
1. 提高系统的吞吐率
2. 提高响应性
3. 充分利用多核处理器资源
4. 最小化对系统资源的使用
5. 简化程序的结构

####多线程的问题与风险

1. 线程安全问题
2. 线程活性问题
3. 上下文切换
4. 可靠性

####线程与进程的区别

- 进程是程序运行的实例，一个进程可以包含多个线程，这些线程共享其所在进程的资源
- 线程是进程中可独立执行的最小单位

####java实习线程的几种方式

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口
4. 使用ExecutorService

####启动线程的start()和run()方法的区别

	start()是启动线程，run()是当成普通方法调用

####怎么终止一个线程？如何优雅的终止线程？

- 使用volatile变量标志进行控制(优雅)
- 使用interrupt()中断方法

####一个线程的生命周期有哪几种状态？之间如何流转？

- **NEW** (已创建而未启动的线程)
- **RUNNABLE** (包含**READY**和**RUNNING**)
- **BLOCKED** (发起阻塞式I/O操作或申请独占资源等待时)
- **WAITING** (**Object.wait()**, **Thread.join()**, **LockSupport.park(Object)**时)
- **TIMED_WAITING** (带有时间限制的**WAITING**)
- **TERMINATED** (已经执行结束的线程)

####线程中wait()和sleep()方法的区别

1. sleep()方法可以在任何地方调用，wait()方法只能在同步块或同步方法中调用
2. sleep()方法主动让出cpu，指定时间后cpu回到该线程继续执行，不会释放同步资源锁；wait()则是让出同步资源锁，让其他正在等待该同步资源锁的线程执行，只有调用了notify()方法，之前wait()的线程才会解除wait状态，去参与同步资源锁的竞争，进而得到执行

####多线程同步有哪几种方法

1. 同步方法
2. 同步代码块
3. 使用volatile
4. 使用锁
5. 使用局部变量

####什么是死锁？如何避免死锁？

两个或更多的线程相互等待对方而被永远暂停，那么就可以称这些线程产生死锁。

######规避死锁常见方法：
- 粗锁法——使用一个粗粒度的锁代替多个锁
- 锁排序法——相关线程使用全局统一的顺序申请锁
- 使用ReentrantLock.tryLock(long,TimeUnit)来申请锁
- 使用开放调用——在调用外部方法时不加锁
- 使用锁的替代品

####多线程之间如何通信

1. 同步
2. while循环
3. wait/notify机制
4. 管道通信

####线程怎样拿到返回结果

	实现Callable接口，通过FutureTask获取

####volatile关键字的作用

1. 保障内存可见性
2. 保障有序性
3. 保障long/double型变量读写操作的原子性

####新建T1,T2,T3三个线程，如何保证它们顺序执行？

	通过Thread.join()进行控制

####怎么控制同一时间只有3个线程运行？

	通过Semaphore控制或用Executors.newFixedThreadPool(3)

####为什么要使用线程池？

1. 减少创建和销毁线程的次数，节省开销
2. 根据系统承受能力调整工作线程数量，防止拖垮系统

####常见的几种线程池并讲讲其中的工作原理

######newCachedThreadPool
	创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

	这种类型的线程池特点是：

	工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger.MAX_VALUE), 这样可灵活的往线程池中添加线程。
	如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。
	终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
	在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。
######newFixedThreadPool
	创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。
######newSingleThreadExecutor
	创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
	如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。
######newScheduleThreadPool
	创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。

####线程池启动线程的submit()和execute()方法有什么不同？

	submit()有返回值，而execute()没有

####CyclicBarrier和CountDownLatch的区别

	| CyclicBarrier | CountDownLatch |
	| 加计数方式     | 减计数方式		 |
	| 可重复		  | 不可重复 	    |

	